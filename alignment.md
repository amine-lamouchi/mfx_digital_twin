## Preparing standardized inputs/outputs for the optimization layer

We're breaking down autoMFX alignment into a set of core tasks. For each one, we define the relevant DoFs, diagnostics, and optimization objectives. The table below lays this out in a unified format that will serve as the interface between the digital twin and the optimization layer.

|              | Input                                                                                                                                                                                                                                                                                                                                                                   | Output                                                                                         | Objective                                                                                                                                                                        |
|---------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Undulator Pointing** | • Get via: `mfx_sim.beam_params['ax']`, `['ay']`  <br> • Set via: `mfx_sim.undulator_pointing(ax=..., ay=...)`  <br> • Units: radians (default: 0)  <br> • Bounds: `abs(ax), abs(ay) < 2.5e-6`                                                                                                                                                                         | • Position: `mfx_sim.beamline.hx2_shared.cx`, `cy` <br>                   | Minimize `sqrt(cx² + cy²)` <br> i.e., bring beam to (0,0) center                                                                                                                |
| **Beam Steering**      | • Get via: `mfx_sim.mr1l4_pitch.wm()`  <br> • Set via: `mfx_sim.mr1l4_pitch.mv(...)` (absolute) or `.mvr(...)` (relative)  <br> • Bounds: must be scanned and manually set using `.set_low_limit()` and `.set_high_limit()`                                                                                                                                        | • Position: `mfx_sim.beamline.DG1_YAG.cx`, `cy`                                                    | Minimize `abs(cx)` <br> Only x varies significantly                                                                                                                            |
| **Transfocator**       | • Identify active lenses: `for crl in mfx_sim.tfs_list: crl.enabled`  <br> • For each active CRL `i`: <br> &nbsp;&nbsp;• Get via: `mfx_sim.tfs_i_x.wm()`, `.tfs_i_y.wm()`  <br> &nbsp;&nbsp;• Set via: `mfx_sim.tfs_i_x.mv(...)`, `.tfs_i_y.mv(...)`  <br> • Bounds: also need to be manually explored and set                                                           | • Position: `mfx_sim.DG2_YAG.cx`, `cy` <br> • Shape (width): `wx`, `wy`                            | Minimize `sqrt(cx² + cy²)` + `abs(wx - wy)` <br> Ensures beam is centered and symmetric (circular spot)                                                                       |
| **von Hamos**          | • After building beamline: `beamLine = vh.build_beamline(energy=mfx_sim.E0, beamH=wx, beamV=wy)`  <br> • DoF access: <br> &nbsp;&nbsp;• Get/Set: `beamLine.vonHamos01.center` (translation)  <br> &nbsp;&nbsp;`beamLine.vonHamos01.pitch`, `beamLine.vonHamos01.yaw`                                                                                                   | • Run ray tracing: <br> &nbsp;&nbsp;`vh.rrun.run_process = vh.run_process` <br> &nbsp;&nbsp;`plots = vh.define_plots()` <br> &nbsp;&nbsp;`vh.xrtrun.run_ray_tracing(...)` <br> • Extract: `plot.cx`, `cy`, `dx/2`, `dy/2` | Minimize `sqrt(cx² + cy²)` + `abs(dx)` <br> i.e., thin vertical strip centered on detector                                                                                     |
